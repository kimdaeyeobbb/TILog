# 람다

## 예제 - [LambdaTest6.java](./LambdaTest6.java)

### 메서드 참조

```java
(left, right) -> Math.max(left, right);
```

- 메서드를 참조하여 매개변수의 정보 및 리턴 타입을 알아내어 불필요한 매개변수를 제거

<br>

#### 정적 메서드와 인스턴스 메서드 참조

- 람다식에서 정적 메서드를 참조할 경우 클래스명 뒤에 `::`기호를 붙이고 정적 메서드명을 기재

```java
클래스 :: 메서드
```

<br>

- 인스턴스 메서드일 경우 객체를 생성한 다음 참조 변수 뒤에 `::`기호를 붙이고 인스턴스 메서드명을 기재

```java
참조변수 :: 메서드
```

<br>

####  생성자 참조

- 객체를 생성하는 것
- 람다식이 단순히 객체를 생성하고 리턴하도록 구성되면 람다식을 생성자 참조로 바꿀 수 있음

```java
(a,b) -> { return new 클래스(a,b) };
```

<br>

- 클래스명 뒤에 `::` 기호를 붙이고 new 연산자를 기술

```java
클래스 :: new
```

- 만약에 생성자가 오버로딩되어 여러 개가 있을 경우, 컴파일러는 함수형 인터페이스의 추상 메서드가 
동일한 매개변수 타입과 개수를 가지고 있는 생성자를 찾아 호출함
<br> (해당 생성자가 존재하지 않으면 컴파일 에러 발생)


<br>


## 예제 - [LambdaTest7.java](./LambdaTest7.java)

- 메서드 호출식만으로도 람다식을 대신할 수 있다


## 예제 - [LambdaTest8.java](./LambdaTest8.java)


## 예제 - [LambdaTest9.java](./LambdaTest9.java)

## 예제 - [LambdaTest10.java](./LambdaTest10.java)

- 구현해야하는 메서드의 사양부터 체크할 것

<br>

## 예제 - [LambdaTest11.java](./LambdaTest11.java)

- Comparable을 상속하지 않으면 두번쨰 인자로 Comparator 객체를 만들어서 전달해야함
  - Comparator 객체가 없다면 내부의 compareTo메서드를 호출하겠다는 뜻





### 매개변수의 메서드 참조

- 람다식으로 제공되는 a 매개변수의 메서드를 호출할 때 b 매개변수를 매개값으로 사용

```java
(a,b) -> { a.instanceMethod(b) };
// 첫번째 인자.메서드(두번쨰 인자)
// 클래스 :: 메서드명으로 대신할 수 있음
```

- a 클래스명 뒤에 `::` 기호를 붙이고 이름을 기술
```java
클래스 :: instanceMethod

String :: compareToIgnoreCase
```

<br>

## 예제 - [LambdaTest12.java](./LambdaTest12.java)

- functional interface를 제네릭 타입으로 만들 수 있음


<br>

# 17. 스트림

- 대용량 데이터 처리를 위해 추가됨

- Java 8부터 Stream API가 추가됨


# I/O Stream

![img.png](img.png)
![img_1.png](img_1.png)

- 자바 프로그램이 수행하는데 있어 필요한 것을 외부로부터 읽거나 내보냄
- byte stream, 문자 stream 등을 이용
- I/O의 타겟 장치는 표준입출력 장치 (Standard I/O)
- readLine은 네트워크에서 오는 애들을 읽을 때 개행문자가 인식되지 않으면 입력이 안된것으로 보므로
개행문자가 나타날 떄까지 계속 읽음
- readLine으로 읽으면 내보낼 때에는 println을 이용해야함 (개행문자 포함하므로)


<br>

# Java8에서 추가된 Stream


- 컬렉션/배열 (데이터가 여러개 들어감)등에 저장된 요소들을 하나씩 참조하면서 코드를 실행할 수 있는 기능
- Java 8부터 컬렉션 및 배열의 요소를 반복 처리하기 위해 스트림을 사용함
<br> (스트림 -> 데이터의 흐름)


- 스트림 사용시 반복문을 사용하지 않고도 컬렉션/배열이 가지는 요소들에 접근 가능
- 이때 수행하고 싶은/처리하는 기능은 람다식(함수)으로 만들어서 전달함 

- 무엇을 할것인지는 람다식으로 전달

```java
Stream <String> stream = list.stream();
stream.forEach( item -> /* item 처리*/ );
```
- List 컬렉션의 stream() 메소드로 Stream 객체를 얻고, forEach() 메소드로 요소를 어떻게 처리할지 람다식으로 제공하여 처리한다.


- Java8부터 새로이 추가된 java.util.stream 패키지에는 여러 Stream API들이 포함되어 있음

![img_5.png](img_5.png)



<br>

## 스트림 객체가 가지는 메서드

- 전달된 람다식에 기반하여 수행함
- 함수형 인터페이스를 인자값으로 갖는 경우가 많다

![img_3.png](img_3.png)


<br>

# 스트림 이용요약

- 스트림객체에서 제공하는 메서드를 이용하여 각각이 동일한 동작을 수행하게 함

![img_4.png](img_4.png)

- `map` -> 스트림 객체가 가지는 요소들에 대해 변화되는 작업을 수행해서 내보냄
- 변환한 다음 `forEach` 메서드를 이용하여 스트림 객체가 가지는 요소에 대해 반복처리 작업 수행
- `System.out::println` -> 내보냄

<br>

# 스트림의 특징

- 스트림이라는 객체를 통해 일관성 있게 처리할 수 있음
- 자료의 대상과 관계없이 동일한 연산을 수행할 수 있음
- ArrayList, LinkedList, HashSet등은 iterator 객체를 만들어서 쓸 수 있음
<br> => 스트림 객체도 스트림 객체를 통해 Collection 데이터들을 다룰 수 있음
<br> => 스트림이 제공하는 여러 메서드와 매커니즘을 이용하여 데이터의 종류의 관계없이 일관성 있게 처리할 수 있음


- 한 번 만들어진 스트림은 재사용될 수 없음 (일회성)


- 스트림 연산은 기존의 자료를 변경하지 않고, 새로운 메모리 위에서 동작함


- 중간연산을 담당하는 메서드와 과 최종 연산을 담당하는 메서드가 구분되어, 최종 연산이 수행된 이후 모든 연산이 적용되는 `지연연산`을 지원함

## 지연연산

- lazy execution. 게으른 수행

- 점(.)과 어떤 메서드를 호출하면 뭐가 호출되었는지 그때그때 보는게 아닌 전체를 살펴보고 효율적인 수행방식을 결정
- 빅데이터 처리를 위해 생성된 API들은 대부분 지연연산을 도입함





<br>


# 중간연산 및 최종연산 처리 담당 메서드

## 중간연산 처리 담당 메서드

- 메서드 리턴값의 유형이 Stream객체 
    - 메서드를 연속적으로 이어서 호출할 수 있음 (체이닝 호출 방식)
    - 리턴결과를 변수에 담지 않아도 되니까 이어서 호출할 수 있음
    - 점(.) 연산자에 의해 최종 연산까지 구현해놓으면 전체적으로 해석을 함


```java
stream.map(...).filter(...).distinct(...)

// map -> 람다식 전달해서 매핑규칙 준수해야함
```





<br>

## 최종연산 처리 담당 메서드

- 리턴값이 Stream 객체가 아님


```java
stream.map(...).filter(...).distinct(...).collect(...) // 불가능
stream.map(...).filter(...).distinct(...).count() // 불가능 -> count는 최종연산을 담당
```


<br>

# 외부 반복자 & 내부 반복자

![img_6.png](img_6.png)

## 외부 반복자

- 일반적으로 사용하는 루프처럼 요소를 사용하는 쪽에서 직접 컬렉션 요소를 하나씩 꺼내 와서 반복 처리
- 기존의 for문을 사용하는 것

<br>

## 내부 반복자

- 처리할 행동(보통 콜백 함수)을 컬렉션 요소에 넘겨주어 반복 처리
- 내부에서 알아서 처리함
- 외부 반복자보다 성능이 뛰어나다


- 스트림을 쓰는 것은 내부 반복자
- 요소 처리 방법을 컬렉션 내부로 주입시켜서 요소를 반복 처리
  
- 개발자 코드에서 제공한 데이터 처리 코드(람다식)를 가지고 컬렉션 내부에서 
요소를 반복 처리 내부 반복자는 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배 시켜 병렬 작업 가능


### 내부 반복자의 특징

- 내부 반복자이므로 처리 속도가 빠르고 병렬 처리에 효율적
- 람다식으로 다양한 요소 처리를 정의
- 중간 처리와 최종 처리를 수행하도록 파이프 라인 형성
- 내부 반복자의 이점은 어떻게 요소를 반복시킬 것인가는 컬렉션에 맡겨두고,
  개발자는 요소 처리 코드에만 집중
- 요소들의 반복 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜
  병렬 작업을 할 수 있게 도와줌

```java
/* 스트림 사용 X */
List <String> list = Arrays.asList("A", "B", "C", "D"); // 스트림 사용 X
        
Iterator<String> iter = list.iterator();
while(iter.hasNext()){
    String name = iter.next();
    System.out.println(name);
}
```

- 데이터가 많을수록 스트림을 사용하는것이 효율적이다

```java
/* 스트림 사용 O */
Stream<String> stream = list.stream();
list.stream().forEach(name -> System.out.println(name));
```



<br>

# 스트림 파이프라인

- 컬렉션의 오리지널 스트림 뒤에 필터링 중간 스트림이 연결될 수 있고, 그 뒤에 매핑 중간 스트림이 연결될 수 있음

![img_7.png](img_7.png)